/**
 * Generated by Scrooge
 *   version: 4.13.0-SNAPSHOT
 *   rev: 952e3625feae4a1a9eeaf4a75d413531b1770809
 *   built at: 20170404-132108
 */
import thrift from 'thrift'
import {Thrift, Protocol, Transport, Int64, AnyProtocolClass} from 'thrift'

import { TodoException } from './TodoException'
import { Todo } from './Todo'
import { CreateRequestContext } from './CreateRequestContext'

/**
 * A simple task service that allows a client to create,
 * complete, and view tasks.
 * You should replace this with your actual service.
 */

export interface ITodoServiceAllArgsArgs {
}

export class TodoServiceAllArgs {
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: ITodoServiceAllArgsArgs) {
    }
    populate(args: ITodoServiceAllArgsArgs) {
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            input.skip(ftype)
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("TodoServiceAllArgs")
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}/**
 * A simple task service that allows a client to create,
 * complete, and view tasks.
 * You should replace this with your actual service.
 */

export interface ITodoServiceAllResultArgs {
    success?: Array<Todo>
}

export class TodoServiceAllResult {
    public success: Array<Todo>
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: ITodoServiceAllResultArgs) {
        if (args) {
            if (args.success != null) {
                this.success = args.success
            }
        }
    }
    populate(args: ITodoServiceAllResultArgs) {
            if (args.success != null) {
                this.success = args.success
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 0:
                    this.success = (() => {
                        const meta = input.readListBegin()
                        const elems = new Array<Todo>()
                        for (let i = 0; i < meta.size; i++) {
                            const elem = (() => {
                        const struct = new Todo()
                        struct.read(input)
                        return struct
                    })()
                    
                            elems.push(elem)
                        }
                        input.readListEnd()
                        return elems
                    })()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("TodoServiceAllResult")
        if (this.success != null) {
            if (this.success !== undefined) {
                const success_item = this.success
                output.writeFieldBegin("success", Thrift.Type.LIST, 0)
                output.writeListBegin(Thrift.Type.STRUCT, success_item.length)
                for (let i = 0; i < success_item.length; i++) {
                    const success_item_element = success_item[i]
                    success_item_element.write(output)
                }
                output.writeListEnd()
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}/**
 * A simple task service that allows a client to create,
 * complete, and view tasks.
 * You should replace this with your actual service.
 */

export interface ITodoServiceFindByNameArgsArgs {
    name: string
}

export class TodoServiceFindByNameArgs {
    public name: string
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: ITodoServiceFindByNameArgsArgs) {
        if (args) {
            if (args.name != null) {
                this.name = args.name
            }
        }
    }
    populate(args: ITodoServiceFindByNameArgsArgs) {
            if (args.name != null) {
                this.name = args.name
            } else {
                throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field name is unset!')
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    this.name = input.readString()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("TodoServiceFindByNameArgs")
        if (this.name != null) {
            if (this.name !== null) {
                const name_item = this.name
                output.writeFieldBegin("name", Thrift.Type.STRING, 1)
                output.writeString(name_item)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}/**
 * A simple task service that allows a client to create,
 * complete, and view tasks.
 * You should replace this with your actual service.
 */

export interface ITodoServiceFindByNameResultArgs {
    success?: Array<Todo>
}

export class TodoServiceFindByNameResult {
    public success: Array<Todo>
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: ITodoServiceFindByNameResultArgs) {
        if (args) {
            if (args.success != null) {
                this.success = args.success
            }
        }
    }
    populate(args: ITodoServiceFindByNameResultArgs) {
            if (args.success != null) {
                this.success = args.success
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 0:
                    this.success = (() => {
                        const meta = input.readListBegin()
                        const elems = new Array<Todo>()
                        for (let i = 0; i < meta.size; i++) {
                            const elem = (() => {
                        const struct = new Todo()
                        struct.read(input)
                        return struct
                    })()
                    
                            elems.push(elem)
                        }
                        input.readListEnd()
                        return elems
                    })()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("TodoServiceFindByNameResult")
        if (this.success != null) {
            if (this.success !== undefined) {
                const success_item = this.success
                output.writeFieldBegin("success", Thrift.Type.LIST, 0)
                output.writeListBegin(Thrift.Type.STRUCT, success_item.length)
                for (let i = 0; i < success_item.length; i++) {
                    const success_item_element = success_item[i]
                    success_item_element.write(output)
                }
                output.writeListEnd()
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}/**
 * A simple task service that allows a client to create,
 * complete, and view tasks.
 * You should replace this with your actual service.
 */

export interface ITodoServiceFindByIdArgsArgs {
    id: Int64
}

export class TodoServiceFindByIdArgs {
    public id: Int64
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: ITodoServiceFindByIdArgsArgs) {
        if (args) {
            if (args.id != null) {
                this.id = args.id
            }
        }
    }
    populate(args: ITodoServiceFindByIdArgsArgs) {
            if (args.id != null) {
                this.id = args.id
            } else {
                throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field id is unset!')
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    this.id = input.readI64()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("TodoServiceFindByIdArgs")
        if (this.id != null) {
            if (true) {
                const id_item = this.id
                output.writeFieldBegin("id", Thrift.Type.I64, 1)
                output.writeI64(id_item)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}/**
 * A simple task service that allows a client to create,
 * complete, and view tasks.
 * You should replace this with your actual service.
 */

export interface ITodoServiceFindByIdResultArgs {
    ex?: TodoException
    success?: Todo
}

export class TodoServiceFindByIdResult {
    public ex: TodoException
    public success: Todo
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: ITodoServiceFindByIdResultArgs) {
        if (args) {
            if (args.ex != null) {
                this.ex = args.ex
            }
            if (args.success != null) {
                this.success = args.success
            }
        }
    }
    populate(args: ITodoServiceFindByIdResultArgs) {
            if (args.ex != null) {
                this.ex = args.ex
            }
            if (args.success != null) {
                this.success = args.success
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    this.ex = (() => {
                        const struct = new TodoException()
                        struct.read(input)
                        return struct
                    })()
                    break
                case 0:
                    this.success = (() => {
                        const struct = new Todo()
                        struct.read(input)
                        return struct
                    })()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("TodoServiceFindByIdResult")
        if (this.ex != null) {
            if (this.ex !== undefined) {
                const ex_item = this.ex
                output.writeFieldBegin("ex", Thrift.Type.STRUCT, 1)
                ex_item.write(output)
                output.writeFieldEnd()
            }
        }
        if (this.success != null) {
            if (this.success !== undefined) {
                const success_item = this.success
                output.writeFieldBegin("success", Thrift.Type.STRUCT, 0)
                success_item.write(output)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}/**
 * A simple task service that allows a client to create,
 * complete, and view tasks.
 * You should replace this with your actual service.
 */

export interface ITodoServiceCreateArgsArgs {
    requestContext: CreateRequestContext
}

export class TodoServiceCreateArgs {
    public requestContext: CreateRequestContext
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: ITodoServiceCreateArgsArgs) {
        if (args) {
            if (args.requestContext != null) {
                this.requestContext = args.requestContext
            }
        }
    }
    populate(args: ITodoServiceCreateArgsArgs) {
            if (args.requestContext != null) {
                this.requestContext = args.requestContext
            } else {
                throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field requestContext is unset!')
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    this.requestContext = (() => {
                        const struct = new CreateRequestContext()
                        struct.read(input)
                        return struct
                    })()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("TodoServiceCreateArgs")
        if (this.requestContext != null) {
            if (this.requestContext !== null) {
                const requestContext_item = this.requestContext
                output.writeFieldBegin("requestContext", Thrift.Type.STRUCT, 1)
                requestContext_item.write(output)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}/**
 * A simple task service that allows a client to create,
 * complete, and view tasks.
 * You should replace this with your actual service.
 */

export interface ITodoServiceCreateResultArgs {
    success?: Int64
}

export class TodoServiceCreateResult {
    public success: Int64
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: ITodoServiceCreateResultArgs) {
        if (args) {
            if (args.success != null) {
                this.success = args.success
            }
        }
    }
    populate(args: ITodoServiceCreateResultArgs) {
            if (args.success != null) {
                this.success = args.success
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 0:
                    this.success = input.readI64()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("TodoServiceCreateResult")
        if (this.success != null) {
            if (this.success !== undefined) {
                const success_item = this.success
                output.writeFieldBegin("success", Thrift.Type.I64, 0)
                output.writeI64(success_item)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}/**
 * A simple task service that allows a client to create,
 * complete, and view tasks.
 * You should replace this with your actual service.
 */

export interface ITodoServiceCompleteArgsArgs {
    id: Int64
}

export class TodoServiceCompleteArgs {
    public id: Int64
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: ITodoServiceCompleteArgsArgs) {
        if (args) {
            if (args.id != null) {
                this.id = args.id
            }
        }
    }
    populate(args: ITodoServiceCompleteArgsArgs) {
            if (args.id != null) {
                this.id = args.id
            } else {
                throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field id is unset!')
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    this.id = input.readI64()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("TodoServiceCompleteArgs")
        if (this.id != null) {
            if (true) {
                const id_item = this.id
                output.writeFieldBegin("id", Thrift.Type.I64, 1)
                output.writeI64(id_item)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}/**
 * A simple task service that allows a client to create,
 * complete, and view tasks.
 * You should replace this with your actual service.
 */

export interface ITodoServiceCompleteResultArgs {
    success?: boolean
}

export class TodoServiceCompleteResult {
    public success: boolean
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: ITodoServiceCompleteResultArgs) {
        if (args) {
            if (args.success != null) {
                this.success = args.success
            }
        }
    }
    populate(args: ITodoServiceCompleteResultArgs) {
            if (args.success != null) {
                this.success = args.success
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 0:
                    this.success = input.readBool()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("TodoServiceCompleteResult")
        if (this.success != null) {
            if (this.success !== undefined) {
                const success_item = this.success
                output.writeFieldBegin("success", Thrift.Type.BOOL, 0)
                output.writeBool(success_item)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}/**
 * A simple task service that allows a client to create,
 * complete, and view tasks.
 * You should replace this with your actual service.
 */

export interface ITodoServiceRemoveArgsArgs {
    id: Int64
}

export class TodoServiceRemoveArgs {
    public id: Int64
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: ITodoServiceRemoveArgsArgs) {
        if (args) {
            if (args.id != null) {
                this.id = args.id
            }
        }
    }
    populate(args: ITodoServiceRemoveArgsArgs) {
            if (args.id != null) {
                this.id = args.id
            } else {
                throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field id is unset!')
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    this.id = input.readI64()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("TodoServiceRemoveArgs")
        if (this.id != null) {
            if (true) {
                const id_item = this.id
                output.writeFieldBegin("id", Thrift.Type.I64, 1)
                output.writeI64(id_item)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}/**
 * A simple task service that allows a client to create,
 * complete, and view tasks.
 * You should replace this with your actual service.
 */

export interface ITodoServiceRemoveResultArgs {
    success?: boolean
}

export class TodoServiceRemoveResult {
    public success: boolean
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: ITodoServiceRemoveResultArgs) {
        if (args) {
            if (args.success != null) {
                this.success = args.success
            }
        }
    }
    populate(args: ITodoServiceRemoveResultArgs) {
            if (args.success != null) {
                this.success = args.success
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 0:
                    this.success = input.readBool()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("TodoServiceRemoveResult")
        if (this.success != null) {
            if (this.success !== undefined) {
                const success_item = this.success
                output.writeFieldBegin("success", Thrift.Type.BOOL, 0)
                output.writeBool(success_item)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}
export class Client {
    private _seqid: number
    public _reqs: {[key: string]: (e?: Error|object, r?: any) => void}

    constructor(public output: Transport, public pClass: AnyProtocolClass) {
        this._seqid = 0
        this._reqs = {}
    }

    public seqid(): number {
        return this._seqid
    }

    public new_seqid(): number {
        return this._seqid += 1
    }

    public all(callback: (e?: Error|object, r?: Array<Todo>) => void): void
    public all(): Promise<Array<Todo>>
    public all(callback?: (e?: Error|object, r?: Array<Todo>) => void): Promise<Array<Todo>>|void {
        this._seqid = this.new_seqid()
        if (callback instanceof Function) {
            this._reqs[this.seqid()] = callback
            this.send_all()
        } else {
            return new Promise<Array<Todo>>((resolve, reject) => {
                this._reqs[this.seqid()] = function(error, result) {
                    if (error) {
                        reject(error)
                    } else {
                        resolve(result)
                    }
                }
                this.send_all()
            })
        }
    }

    public send_all(): void {
        const output = new (this.pClass as any)(this.output)
        output.writeMessageBegin("all", Thrift.MessageType.CALL, this.seqid())
        const args = new TodoServiceAllArgs()
        args.populate({  })
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }

    public recv_all(input: Protocol, mtype: Thrift.MessageType, rseqid: number): void {
        const noop = () => null
        let callback = this._reqs[rseqid] || noop
        delete this._reqs[rseqid]
        if (mtype === Thrift.MessageType.EXCEPTION) {
            const x = new Thrift.TApplicationException()
            x.read(input)
            input.readMessageEnd()
            return callback(x)
        }
        const result = new TodoServiceAllResult()
        result.read(input)
        input.readMessageEnd()

        // Dont check if
        if (result.success != null) {
            return callback(undefined, result.success)
        }
        return callback(new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, "all failed: unknown result"))
    }
        public findByName(name: string, callback: (e?: Error|object, r?: Array<Todo>) => void): void
    public findByName(name: string, ): Promise<Array<Todo>>
    public findByName(name: string, callback?: (e?: Error|object, r?: Array<Todo>) => void): Promise<Array<Todo>>|void {
        this._seqid = this.new_seqid()
        if (callback instanceof Function) {
            this._reqs[this.seqid()] = callback
            this.send_findByName(name )
        } else {
            return new Promise<Array<Todo>>((resolve, reject) => {
                this._reqs[this.seqid()] = function(error, result) {
                    if (error) {
                        reject(error)
                    } else {
                        resolve(result)
                    }
                }
                this.send_findByName(name, )
            })
        }
    }

    public send_findByName(name: string, ): void {
        const output = new (this.pClass as any)(this.output)
        output.writeMessageBegin("findByName", Thrift.MessageType.CALL, this.seqid())
        const args = new TodoServiceFindByNameArgs()
        args.populate({ name,  })
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }

    public recv_findByName(input: Protocol, mtype: Thrift.MessageType, rseqid: number): void {
        const noop = () => null
        let callback = this._reqs[rseqid] || noop
        delete this._reqs[rseqid]
        if (mtype === Thrift.MessageType.EXCEPTION) {
            const x = new Thrift.TApplicationException()
            x.read(input)
            input.readMessageEnd()
            return callback(x)
        }
        const result = new TodoServiceFindByNameResult()
        result.read(input)
        input.readMessageEnd()

        // Dont check if
        if (result.success != null) {
            return callback(undefined, result.success)
        }
        return callback(new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, "findByName failed: unknown result"))
    }
        public findById(id: Int64, callback: (e?: Error|object, r?: Todo) => void): void
    public findById(id: Int64, ): Promise<Todo>
    public findById(id: Int64, callback?: (e?: Error|object, r?: Todo) => void): Promise<Todo>|void {
        this._seqid = this.new_seqid()
        if (callback instanceof Function) {
            this._reqs[this.seqid()] = callback
            this.send_findById(id )
        } else {
            return new Promise<Todo>((resolve, reject) => {
                this._reqs[this.seqid()] = function(error, result) {
                    if (error) {
                        reject(error)
                    } else {
                        resolve(result)
                    }
                }
                this.send_findById(id, )
            })
        }
    }

    public send_findById(id: Int64, ): void {
        const output = new (this.pClass as any)(this.output)
        output.writeMessageBegin("findById", Thrift.MessageType.CALL, this.seqid())
        const args = new TodoServiceFindByIdArgs()
        args.populate({ id,  })
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }

    public recv_findById(input: Protocol, mtype: Thrift.MessageType, rseqid: number): void {
        const noop = () => null
        let callback = this._reqs[rseqid] || noop
        delete this._reqs[rseqid]
        if (mtype === Thrift.MessageType.EXCEPTION) {
            const x = new Thrift.TApplicationException()
            x.read(input)
            input.readMessageEnd()
            return callback(x)
        }
        const result = new TodoServiceFindByIdResult()
        result.read(input)
        input.readMessageEnd()

        // Dont check if
        if (result.ex != null) {
            return callback(result.ex)
        }
        if (result.success != null) {
            return callback(undefined, result.success)
        }
        return callback(new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, "findById failed: unknown result"))
    }
        public create(requestContext: CreateRequestContext, callback: (e?: Error|object, r?: Int64) => void): void
    public create(requestContext: CreateRequestContext, ): Promise<Int64>
    public create(requestContext: CreateRequestContext, callback?: (e?: Error|object, r?: Int64) => void): Promise<Int64>|void {
        this._seqid = this.new_seqid()
        if (callback instanceof Function) {
            this._reqs[this.seqid()] = callback
            this.send_create(requestContext )
        } else {
            return new Promise<Int64>((resolve, reject) => {
                this._reqs[this.seqid()] = function(error, result) {
                    if (error) {
                        reject(error)
                    } else {
                        resolve(result)
                    }
                }
                this.send_create(requestContext, )
            })
        }
    }

    public send_create(requestContext: CreateRequestContext, ): void {
        const output = new (this.pClass as any)(this.output)
        output.writeMessageBegin("create", Thrift.MessageType.CALL, this.seqid())
        const args = new TodoServiceCreateArgs()
        args.populate({ requestContext,  })
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }

    public recv_create(input: Protocol, mtype: Thrift.MessageType, rseqid: number): void {
        const noop = () => null
        let callback = this._reqs[rseqid] || noop
        delete this._reqs[rseqid]
        if (mtype === Thrift.MessageType.EXCEPTION) {
            const x = new Thrift.TApplicationException()
            x.read(input)
            input.readMessageEnd()
            return callback(x)
        }
        const result = new TodoServiceCreateResult()
        result.read(input)
        input.readMessageEnd()

        // Dont check if
        if (result.success != null) {
            return callback(undefined, result.success)
        }
        return callback(new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, "create failed: unknown result"))
    }
        public complete(id: Int64, callback: (e?: Error|object, r?: boolean) => void): void
    public complete(id: Int64, ): Promise<boolean>
    public complete(id: Int64, callback?: (e?: Error|object, r?: boolean) => void): Promise<boolean>|void {
        this._seqid = this.new_seqid()
        if (callback instanceof Function) {
            this._reqs[this.seqid()] = callback
            this.send_complete(id )
        } else {
            return new Promise<boolean>((resolve, reject) => {
                this._reqs[this.seqid()] = function(error, result) {
                    if (error) {
                        reject(error)
                    } else {
                        resolve(result)
                    }
                }
                this.send_complete(id, )
            })
        }
    }

    public send_complete(id: Int64, ): void {
        const output = new (this.pClass as any)(this.output)
        output.writeMessageBegin("complete", Thrift.MessageType.CALL, this.seqid())
        const args = new TodoServiceCompleteArgs()
        args.populate({ id,  })
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }

    public recv_complete(input: Protocol, mtype: Thrift.MessageType, rseqid: number): void {
        const noop = () => null
        let callback = this._reqs[rseqid] || noop
        delete this._reqs[rseqid]
        if (mtype === Thrift.MessageType.EXCEPTION) {
            const x = new Thrift.TApplicationException()
            x.read(input)
            input.readMessageEnd()
            return callback(x)
        }
        const result = new TodoServiceCompleteResult()
        result.read(input)
        input.readMessageEnd()

        // Dont check if
        if (result.success != null) {
            return callback(undefined, result.success)
        }
        return callback(new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, "complete failed: unknown result"))
    }
        public remove(id: Int64, callback: (e?: Error|object, r?: boolean) => void): void
    public remove(id: Int64, ): Promise<boolean>
    public remove(id: Int64, callback?: (e?: Error|object, r?: boolean) => void): Promise<boolean>|void {
        this._seqid = this.new_seqid()
        if (callback instanceof Function) {
            this._reqs[this.seqid()] = callback
            this.send_remove(id )
        } else {
            return new Promise<boolean>((resolve, reject) => {
                this._reqs[this.seqid()] = function(error, result) {
                    if (error) {
                        reject(error)
                    } else {
                        resolve(result)
                    }
                }
                this.send_remove(id, )
            })
        }
    }

    public send_remove(id: Int64, ): void {
        const output = new (this.pClass as any)(this.output)
        output.writeMessageBegin("remove", Thrift.MessageType.CALL, this.seqid())
        const args = new TodoServiceRemoveArgs()
        args.populate({ id,  })
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }

    public recv_remove(input: Protocol, mtype: Thrift.MessageType, rseqid: number): void {
        const noop = () => null
        let callback = this._reqs[rseqid] || noop
        delete this._reqs[rseqid]
        if (mtype === Thrift.MessageType.EXCEPTION) {
            const x = new Thrift.TApplicationException()
            x.read(input)
            input.readMessageEnd()
            return callback(x)
        }
        const result = new TodoServiceRemoveResult()
        result.read(input)
        input.readMessageEnd()

        // Dont check if
        if (result.success != null) {
            return callback(undefined, result.success)
        }
        return callback(new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, "remove failed: unknown result"))
    }
    }

export class Processor {
    private _handler

    constructor(handler) {
        this._handler = handler
    }

    public process(input: Protocol, output: Protocol) {
        const r = input.readMessageBegin()
        if (this["process_" + r.fname]) {
            return this["process_" + r.fname].call(this, r.rseqid, input, output)
        } else {
            input.skip(Thrift.Type.STRUCT)
            input.readMessageEnd()
            const err = `Unknown function ${r.fname}`
            const x = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN_METHOD, err)
            output.writeMessageBegin(r.fname, Thrift.MessageType.EXCEPTION, r.rseqid)
            x.write(output)
            output.writeMessageEnd()
            output.flush()
        }
    }

    public process_all(seqid: number, input: Protocol, output: Protocol) {
        const args = new TodoServiceAllArgs()
        args.read(input)
        input.readMessageEnd()
        if (this._handler.all.length === 0) {
            // TODO: Im a bit iffy on this
            new Promise<Array<Todo>>((resolve, reject) => {
                try {
                    resolve(
                        this._handler.all()
                    )
                } catch (e) {
                    reject(e)
                }
            }).then((data: Array<Todo>) => {
                const result = new TodoServiceAllResult({success: data})
                output.writeMessageBegin("all", Thrift.MessageType.REPLY, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            }).catch((err: Error) => {
                const result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                output.writeMessageBegin("all", Thrift.MessageType.EXCEPTION, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        } else {
            this._handler.all((err?: Error, data?: Array<Todo>) => {
                let result
                if (err == null) {
                    result = new TodoServiceAllResult()
                    result.populate((err != null ? err : {success: data}))
                    output.writeMessageBegin("all", Thrift.MessageType.REPLY, seqid)
                } else {
                    result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                    output.writeMessageBegin("all", Thrift.MessageType.EXCEPTION, seqid)
                }
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        }
    }
    public process_findByName(seqid: number, input: Protocol, output: Protocol) {
        const args = new TodoServiceFindByNameArgs()
        args.read(input)
        input.readMessageEnd()
        if (this._handler.findByName.length === 1) {
            // TODO: Im a bit iffy on this
            new Promise<Array<Todo>>((resolve, reject) => {
                try {
                    resolve(
                        this._handler.findByName(args.name, )
                    )
                } catch (e) {
                    reject(e)
                }
            }).then((data: Array<Todo>) => {
                const result = new TodoServiceFindByNameResult({success: data})
                output.writeMessageBegin("findByName", Thrift.MessageType.REPLY, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            }).catch((err: Error) => {
                const result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                output.writeMessageBegin("findByName", Thrift.MessageType.EXCEPTION, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        } else {
            this._handler.findByName(args.name, (err?: Error, data?: Array<Todo>) => {
                let result
                if (err == null) {
                    result = new TodoServiceFindByNameResult()
                    result.populate((err != null ? err : {success: data}))
                    output.writeMessageBegin("findByName", Thrift.MessageType.REPLY, seqid)
                } else {
                    result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                    output.writeMessageBegin("findByName", Thrift.MessageType.EXCEPTION, seqid)
                }
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        }
    }
    public process_findById(seqid: number, input: Protocol, output: Protocol) {
        const args = new TodoServiceFindByIdArgs()
        args.read(input)
        input.readMessageEnd()
        if (this._handler.findById.length === 1) {
            // TODO: Im a bit iffy on this
            new Promise<Todo>((resolve, reject) => {
                try {
                    resolve(
                        this._handler.findById(args.id, )
                    )
                } catch (e) {
                    reject(e)
                }
            }).then((data: Todo) => {
                const result = new TodoServiceFindByIdResult({success: data})
                output.writeMessageBegin("findById", Thrift.MessageType.REPLY, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            }).catch((err: Error) => {
                const result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                output.writeMessageBegin("findById", Thrift.MessageType.EXCEPTION, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        } else {
            this._handler.findById(args.id, (err?: Error, data?: Todo) => {
                let result
                if (err == null) {
                    result = new TodoServiceFindByIdResult()
                    result.populate((err != null ? err : {success: data}))
                    output.writeMessageBegin("findById", Thrift.MessageType.REPLY, seqid)
                } else {
                    result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                    output.writeMessageBegin("findById", Thrift.MessageType.EXCEPTION, seqid)
                }
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        }
    }
    public process_create(seqid: number, input: Protocol, output: Protocol) {
        const args = new TodoServiceCreateArgs()
        args.read(input)
        input.readMessageEnd()
        if (this._handler.create.length === 1) {
            // TODO: Im a bit iffy on this
            new Promise<Int64>((resolve, reject) => {
                try {
                    resolve(
                        this._handler.create(args.requestContext, )
                    )
                } catch (e) {
                    reject(e)
                }
            }).then((data: Int64) => {
                const result = new TodoServiceCreateResult({success: data})
                output.writeMessageBegin("create", Thrift.MessageType.REPLY, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            }).catch((err: Error) => {
                const result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                output.writeMessageBegin("create", Thrift.MessageType.EXCEPTION, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        } else {
            this._handler.create(args.requestContext, (err?: Error, data?: Int64) => {
                let result
                if (err == null) {
                    result = new TodoServiceCreateResult()
                    result.populate((err != null ? err : {success: data}))
                    output.writeMessageBegin("create", Thrift.MessageType.REPLY, seqid)
                } else {
                    result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                    output.writeMessageBegin("create", Thrift.MessageType.EXCEPTION, seqid)
                }
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        }
    }
    public process_complete(seqid: number, input: Protocol, output: Protocol) {
        const args = new TodoServiceCompleteArgs()
        args.read(input)
        input.readMessageEnd()
        if (this._handler.complete.length === 1) {
            // TODO: Im a bit iffy on this
            new Promise<boolean>((resolve, reject) => {
                try {
                    resolve(
                        this._handler.complete(args.id, )
                    )
                } catch (e) {
                    reject(e)
                }
            }).then((data: boolean) => {
                const result = new TodoServiceCompleteResult({success: data})
                output.writeMessageBegin("complete", Thrift.MessageType.REPLY, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            }).catch((err: Error) => {
                const result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                output.writeMessageBegin("complete", Thrift.MessageType.EXCEPTION, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        } else {
            this._handler.complete(args.id, (err?: Error, data?: boolean) => {
                let result
                if (err == null) {
                    result = new TodoServiceCompleteResult()
                    result.populate((err != null ? err : {success: data}))
                    output.writeMessageBegin("complete", Thrift.MessageType.REPLY, seqid)
                } else {
                    result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                    output.writeMessageBegin("complete", Thrift.MessageType.EXCEPTION, seqid)
                }
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        }
    }
    public process_remove(seqid: number, input: Protocol, output: Protocol) {
        const args = new TodoServiceRemoveArgs()
        args.read(input)
        input.readMessageEnd()
        if (this._handler.remove.length === 1) {
            // TODO: Im a bit iffy on this
            new Promise<boolean>((resolve, reject) => {
                try {
                    resolve(
                        this._handler.remove(args.id, )
                    )
                } catch (e) {
                    reject(e)
                }
            }).then((data: boolean) => {
                const result = new TodoServiceRemoveResult({success: data})
                output.writeMessageBegin("remove", Thrift.MessageType.REPLY, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            }).catch((err: Error) => {
                const result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                output.writeMessageBegin("remove", Thrift.MessageType.EXCEPTION, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        } else {
            this._handler.remove(args.id, (err?: Error, data?: boolean) => {
                let result
                if (err == null) {
                    result = new TodoServiceRemoveResult()
                    result.populate((err != null ? err : {success: data}))
                    output.writeMessageBegin("remove", Thrift.MessageType.REPLY, seqid)
                } else {
                    result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                    output.writeMessageBegin("remove", Thrift.MessageType.EXCEPTION, seqid)
                }
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        }
    }
    
}
