/**
 * Generated by Scrooge
 *   version: 4.13.0-SNAPSHOT
 *   rev: 952e3625feae4a1a9eeaf4a75d413531b1770809
 *   built at: 20170404-132053
 */
import thrift from 'thrift'
import {Thrift, Protocol, Transport, Int64, AnyProtocolClass} from 'thrift'

import { ExampleRequest } from './ExampleRequest'
import { ExampleResponse } from './ExampleResponse'
import { ExampleException } from './ExampleException'


export interface IFinagleTestServiceWillSucceedArgsArgs {
    req: ExampleRequest
}

export class FinagleTestServiceWillSucceedArgs {
    public req: ExampleRequest
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: IFinagleTestServiceWillSucceedArgsArgs) {
        if (args) {
            if (args.req != null) {
                this.req = args.req
            }
        }
    }
    populate(args: IFinagleTestServiceWillSucceedArgsArgs) {
            if (args.req != null) {
                this.req = args.req
            } else {
                throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field req is unset!')
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    this.req = (() => {
                        const struct = new ExampleRequest()
                        struct.read(input)
                        return struct
                    })()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("FinagleTestServiceWillSucceedArgs")
        if (this.req != null) {
            if (this.req !== null) {
                const req_item = this.req
                output.writeFieldBegin("req", Thrift.Type.STRUCT, 1)
                req_item.write(output)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}
export interface IFinagleTestServiceWillSucceedResultArgs {
    ex?: ExampleException
    success?: ExampleResponse
}

export class FinagleTestServiceWillSucceedResult {
    public ex: ExampleException
    public success: ExampleResponse
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: IFinagleTestServiceWillSucceedResultArgs) {
        if (args) {
            if (args.ex != null) {
                this.ex = args.ex
            }
            if (args.success != null) {
                this.success = args.success
            }
        }
    }
    populate(args: IFinagleTestServiceWillSucceedResultArgs) {
            if (args.ex != null) {
                this.ex = args.ex
            }
            if (args.success != null) {
                this.success = args.success
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    this.ex = (() => {
                        const struct = new ExampleException()
                        struct.read(input)
                        return struct
                    })()
                    break
                case 0:
                    this.success = (() => {
                        const struct = new ExampleResponse()
                        struct.read(input)
                        return struct
                    })()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("FinagleTestServiceWillSucceedResult")
        if (this.ex != null) {
            if (this.ex !== undefined) {
                const ex_item = this.ex
                output.writeFieldBegin("ex", Thrift.Type.STRUCT, 1)
                ex_item.write(output)
                output.writeFieldEnd()
            }
        }
        if (this.success != null) {
            if (this.success !== undefined) {
                const success_item = this.success
                output.writeFieldBegin("success", Thrift.Type.STRUCT, 0)
                success_item.write(output)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}
export interface IFinagleTestServiceIdlExceptionArgsArgs {
    req: ExampleRequest
}

export class FinagleTestServiceIdlExceptionArgs {
    public req: ExampleRequest
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: IFinagleTestServiceIdlExceptionArgsArgs) {
        if (args) {
            if (args.req != null) {
                this.req = args.req
            }
        }
    }
    populate(args: IFinagleTestServiceIdlExceptionArgsArgs) {
            if (args.req != null) {
                this.req = args.req
            } else {
                throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field req is unset!')
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    this.req = (() => {
                        const struct = new ExampleRequest()
                        struct.read(input)
                        return struct
                    })()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("FinagleTestServiceIdlExceptionArgs")
        if (this.req != null) {
            if (this.req !== null) {
                const req_item = this.req
                output.writeFieldBegin("req", Thrift.Type.STRUCT, 1)
                req_item.write(output)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}
export interface IFinagleTestServiceIdlExceptionResultArgs {
    ex?: ExampleException
    success?: ExampleResponse
}

export class FinagleTestServiceIdlExceptionResult {
    public ex: ExampleException
    public success: ExampleResponse
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: IFinagleTestServiceIdlExceptionResultArgs) {
        if (args) {
            if (args.ex != null) {
                this.ex = args.ex
            }
            if (args.success != null) {
                this.success = args.success
            }
        }
    }
    populate(args: IFinagleTestServiceIdlExceptionResultArgs) {
            if (args.ex != null) {
                this.ex = args.ex
            }
            if (args.success != null) {
                this.success = args.success
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    this.ex = (() => {
                        const struct = new ExampleException()
                        struct.read(input)
                        return struct
                    })()
                    break
                case 0:
                    this.success = (() => {
                        const struct = new ExampleResponse()
                        struct.read(input)
                        return struct
                    })()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("FinagleTestServiceIdlExceptionResult")
        if (this.ex != null) {
            if (this.ex !== undefined) {
                const ex_item = this.ex
                output.writeFieldBegin("ex", Thrift.Type.STRUCT, 1)
                ex_item.write(output)
                output.writeFieldEnd()
            }
        }
        if (this.success != null) {
            if (this.success !== undefined) {
                const success_item = this.success
                output.writeFieldBegin("success", Thrift.Type.STRUCT, 0)
                success_item.write(output)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}
export interface IFinagleTestServiceAuthExceptionArgsArgs {
    req: ExampleRequest
}

export class FinagleTestServiceAuthExceptionArgs {
    public req: ExampleRequest
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: IFinagleTestServiceAuthExceptionArgsArgs) {
        if (args) {
            if (args.req != null) {
                this.req = args.req
            }
        }
    }
    populate(args: IFinagleTestServiceAuthExceptionArgsArgs) {
            if (args.req != null) {
                this.req = args.req
            } else {
                throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field req is unset!')
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    this.req = (() => {
                        const struct = new ExampleRequest()
                        struct.read(input)
                        return struct
                    })()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("FinagleTestServiceAuthExceptionArgs")
        if (this.req != null) {
            if (this.req !== null) {
                const req_item = this.req
                output.writeFieldBegin("req", Thrift.Type.STRUCT, 1)
                req_item.write(output)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}
export interface IFinagleTestServiceAuthExceptionResultArgs {
    ex?: ExampleException
    success?: ExampleResponse
}

export class FinagleTestServiceAuthExceptionResult {
    public ex: ExampleException
    public success: ExampleResponse
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: IFinagleTestServiceAuthExceptionResultArgs) {
        if (args) {
            if (args.ex != null) {
                this.ex = args.ex
            }
            if (args.success != null) {
                this.success = args.success
            }
        }
    }
    populate(args: IFinagleTestServiceAuthExceptionResultArgs) {
            if (args.ex != null) {
                this.ex = args.ex
            }
            if (args.success != null) {
                this.success = args.success
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    this.ex = (() => {
                        const struct = new ExampleException()
                        struct.read(input)
                        return struct
                    })()
                    break
                case 0:
                    this.success = (() => {
                        const struct = new ExampleResponse()
                        struct.read(input)
                        return struct
                    })()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("FinagleTestServiceAuthExceptionResult")
        if (this.ex != null) {
            if (this.ex !== undefined) {
                const ex_item = this.ex
                output.writeFieldBegin("ex", Thrift.Type.STRUCT, 1)
                ex_item.write(output)
                output.writeFieldEnd()
            }
        }
        if (this.success != null) {
            if (this.success !== undefined) {
                const success_item = this.success
                output.writeFieldBegin("success", Thrift.Type.STRUCT, 0)
                success_item.write(output)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}
export interface IFinagleTestServiceOtherExceptionArgsArgs {
    req: ExampleRequest
}

export class FinagleTestServiceOtherExceptionArgs {
    public req: ExampleRequest
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: IFinagleTestServiceOtherExceptionArgsArgs) {
        if (args) {
            if (args.req != null) {
                this.req = args.req
            }
        }
    }
    populate(args: IFinagleTestServiceOtherExceptionArgsArgs) {
            if (args.req != null) {
                this.req = args.req
            } else {
                throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field req is unset!')
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    this.req = (() => {
                        const struct = new ExampleRequest()
                        struct.read(input)
                        return struct
                    })()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("FinagleTestServiceOtherExceptionArgs")
        if (this.req != null) {
            if (this.req !== null) {
                const req_item = this.req
                output.writeFieldBegin("req", Thrift.Type.STRUCT, 1)
                req_item.write(output)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}
export interface IFinagleTestServiceOtherExceptionResultArgs {
    ex?: ExampleException
    success?: ExampleResponse
}

export class FinagleTestServiceOtherExceptionResult {
    public ex: ExampleException
    public success: ExampleResponse
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: IFinagleTestServiceOtherExceptionResultArgs) {
        if (args) {
            if (args.ex != null) {
                this.ex = args.ex
            }
            if (args.success != null) {
                this.success = args.success
            }
        }
    }
    populate(args: IFinagleTestServiceOtherExceptionResultArgs) {
            if (args.ex != null) {
                this.ex = args.ex
            }
            if (args.success != null) {
                this.success = args.success
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 1:
                    this.ex = (() => {
                        const struct = new ExampleException()
                        struct.read(input)
                        return struct
                    })()
                    break
                case 0:
                    this.success = (() => {
                        const struct = new ExampleResponse()
                        struct.read(input)
                        return struct
                    })()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("FinagleTestServiceOtherExceptionResult")
        if (this.ex != null) {
            if (this.ex !== undefined) {
                const ex_item = this.ex
                output.writeFieldBegin("ex", Thrift.Type.STRUCT, 1)
                ex_item.write(output)
                output.writeFieldEnd()
            }
        }
        if (this.success != null) {
            if (this.success !== undefined) {
                const success_item = this.success
                output.writeFieldBegin("success", Thrift.Type.STRUCT, 0)
                success_item.write(output)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}
export interface IFinagleTestServiceCheckContextArgsArgs {
}

export class FinagleTestServiceCheckContextArgs {
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: IFinagleTestServiceCheckContextArgsArgs) {
    }
    populate(args: IFinagleTestServiceCheckContextArgsArgs) {
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            input.skip(ftype)
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("FinagleTestServiceCheckContextArgs")
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}
export interface IFinagleTestServiceCheckContextResultArgs {
    success?: string
}

export class FinagleTestServiceCheckContextResult {
    public success: string
    // If possible, populate this with .populate method instead so that
    // we can ensure the struct is constructed correctly
constructor(args?: IFinagleTestServiceCheckContextResultArgs) {
        if (args) {
            if (args.success != null) {
                this.success = args.success
            }
        }
    }
    populate(args: IFinagleTestServiceCheckContextResultArgs) {
            if (args.success != null) {
                this.success = args.success
            }
    }

    public read(input: Protocol): void {
        input.readStructBegin()
        while (true) {
    const {ftype, fid} = input.readFieldBegin()
            if (ftype === Thrift.Type.STOP) {
                break
            }
            switch (fid) {
                case 0:
                    this.success = input.readString()
                    break
                default:
                    input.skip(ftype)
            }
            input.readFieldEnd()
        }
        input.readStructEnd()
        return
    }

    public write(output: Protocol): void {
        output.writeStructBegin("FinagleTestServiceCheckContextResult")
        if (this.success != null) {
            if (this.success !== undefined) {
                const success_item = this.success
                output.writeFieldBegin("success", Thrift.Type.STRING, 0)
                output.writeString(success_item)
                output.writeFieldEnd()
            }
        }
        output.writeFieldStop()
        output.writeStructEnd()
        return
    }
}
export class Client {
    private _seqid: number
    public _reqs: {[key: string]: (e?: Error|object, r?: any) => void}

    constructor(public output: Transport, public pClass: AnyProtocolClass) {
        this._seqid = 0
        this._reqs = {}
    }

    public seqid(): number {
        return this._seqid
    }

    public new_seqid(): number {
        return this._seqid += 1
    }

    public willSucceed(req: ExampleRequest, callback: (e?: Error|object, r?: ExampleResponse) => void): void
    public willSucceed(req: ExampleRequest, ): Promise<ExampleResponse>
    public willSucceed(req: ExampleRequest, callback?: (e?: Error|object, r?: ExampleResponse) => void): Promise<ExampleResponse>|void {
        this._seqid = this.new_seqid()
        if (callback instanceof Function) {
            this._reqs[this.seqid()] = callback
            this.send_willSucceed(req )
        } else {
            return new Promise<ExampleResponse>((resolve, reject) => {
                this._reqs[this.seqid()] = function(error, result) {
                    if (error) {
                        reject(error)
                    } else {
                        resolve(result)
                    }
                }
                this.send_willSucceed(req, )
            })
        }
    }

    public send_willSucceed(req: ExampleRequest, ): void {
        const output = new (this.pClass as any)(this.output)
        output.writeMessageBegin("willSucceed", Thrift.MessageType.CALL, this.seqid())
        const args = new FinagleTestServiceWillSucceedArgs()
        args.populate({ req,  })
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }

    public recv_willSucceed(input: Protocol, mtype: Thrift.MessageType, rseqid: number): void {
        const noop = () => null
        let callback = this._reqs[rseqid] || noop
        delete this._reqs[rseqid]
        if (mtype === Thrift.MessageType.EXCEPTION) {
            const x = new Thrift.TApplicationException()
            x.read(input)
            input.readMessageEnd()
            return callback(x)
        }
        const result = new FinagleTestServiceWillSucceedResult()
        result.read(input)
        input.readMessageEnd()

        // Dont check if
        if (result.ex != null) {
            return callback(result.ex)
        }
        if (result.success != null) {
            return callback(undefined, result.success)
        }
        return callback(new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, "willSucceed failed: unknown result"))
    }
        public idlException(req: ExampleRequest, callback: (e?: Error|object, r?: ExampleResponse) => void): void
    public idlException(req: ExampleRequest, ): Promise<ExampleResponse>
    public idlException(req: ExampleRequest, callback?: (e?: Error|object, r?: ExampleResponse) => void): Promise<ExampleResponse>|void {
        this._seqid = this.new_seqid()
        if (callback instanceof Function) {
            this._reqs[this.seqid()] = callback
            this.send_idlException(req )
        } else {
            return new Promise<ExampleResponse>((resolve, reject) => {
                this._reqs[this.seqid()] = function(error, result) {
                    if (error) {
                        reject(error)
                    } else {
                        resolve(result)
                    }
                }
                this.send_idlException(req, )
            })
        }
    }

    public send_idlException(req: ExampleRequest, ): void {
        const output = new (this.pClass as any)(this.output)
        output.writeMessageBegin("idlException", Thrift.MessageType.CALL, this.seqid())
        const args = new FinagleTestServiceIdlExceptionArgs()
        args.populate({ req,  })
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }

    public recv_idlException(input: Protocol, mtype: Thrift.MessageType, rseqid: number): void {
        const noop = () => null
        let callback = this._reqs[rseqid] || noop
        delete this._reqs[rseqid]
        if (mtype === Thrift.MessageType.EXCEPTION) {
            const x = new Thrift.TApplicationException()
            x.read(input)
            input.readMessageEnd()
            return callback(x)
        }
        const result = new FinagleTestServiceIdlExceptionResult()
        result.read(input)
        input.readMessageEnd()

        // Dont check if
        if (result.ex != null) {
            return callback(result.ex)
        }
        if (result.success != null) {
            return callback(undefined, result.success)
        }
        return callback(new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, "idlException failed: unknown result"))
    }
        public authException(req: ExampleRequest, callback: (e?: Error|object, r?: ExampleResponse) => void): void
    public authException(req: ExampleRequest, ): Promise<ExampleResponse>
    public authException(req: ExampleRequest, callback?: (e?: Error|object, r?: ExampleResponse) => void): Promise<ExampleResponse>|void {
        this._seqid = this.new_seqid()
        if (callback instanceof Function) {
            this._reqs[this.seqid()] = callback
            this.send_authException(req )
        } else {
            return new Promise<ExampleResponse>((resolve, reject) => {
                this._reqs[this.seqid()] = function(error, result) {
                    if (error) {
                        reject(error)
                    } else {
                        resolve(result)
                    }
                }
                this.send_authException(req, )
            })
        }
    }

    public send_authException(req: ExampleRequest, ): void {
        const output = new (this.pClass as any)(this.output)
        output.writeMessageBegin("authException", Thrift.MessageType.CALL, this.seqid())
        const args = new FinagleTestServiceAuthExceptionArgs()
        args.populate({ req,  })
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }

    public recv_authException(input: Protocol, mtype: Thrift.MessageType, rseqid: number): void {
        const noop = () => null
        let callback = this._reqs[rseqid] || noop
        delete this._reqs[rseqid]
        if (mtype === Thrift.MessageType.EXCEPTION) {
            const x = new Thrift.TApplicationException()
            x.read(input)
            input.readMessageEnd()
            return callback(x)
        }
        const result = new FinagleTestServiceAuthExceptionResult()
        result.read(input)
        input.readMessageEnd()

        // Dont check if
        if (result.ex != null) {
            return callback(result.ex)
        }
        if (result.success != null) {
            return callback(undefined, result.success)
        }
        return callback(new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, "authException failed: unknown result"))
    }
        public otherException(req: ExampleRequest, callback: (e?: Error|object, r?: ExampleResponse) => void): void
    public otherException(req: ExampleRequest, ): Promise<ExampleResponse>
    public otherException(req: ExampleRequest, callback?: (e?: Error|object, r?: ExampleResponse) => void): Promise<ExampleResponse>|void {
        this._seqid = this.new_seqid()
        if (callback instanceof Function) {
            this._reqs[this.seqid()] = callback
            this.send_otherException(req )
        } else {
            return new Promise<ExampleResponse>((resolve, reject) => {
                this._reqs[this.seqid()] = function(error, result) {
                    if (error) {
                        reject(error)
                    } else {
                        resolve(result)
                    }
                }
                this.send_otherException(req, )
            })
        }
    }

    public send_otherException(req: ExampleRequest, ): void {
        const output = new (this.pClass as any)(this.output)
        output.writeMessageBegin("otherException", Thrift.MessageType.CALL, this.seqid())
        const args = new FinagleTestServiceOtherExceptionArgs()
        args.populate({ req,  })
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }

    public recv_otherException(input: Protocol, mtype: Thrift.MessageType, rseqid: number): void {
        const noop = () => null
        let callback = this._reqs[rseqid] || noop
        delete this._reqs[rseqid]
        if (mtype === Thrift.MessageType.EXCEPTION) {
            const x = new Thrift.TApplicationException()
            x.read(input)
            input.readMessageEnd()
            return callback(x)
        }
        const result = new FinagleTestServiceOtherExceptionResult()
        result.read(input)
        input.readMessageEnd()

        // Dont check if
        if (result.ex != null) {
            return callback(result.ex)
        }
        if (result.success != null) {
            return callback(undefined, result.success)
        }
        return callback(new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, "otherException failed: unknown result"))
    }
        public checkContext(callback: (e?: Error|object, r?: string) => void): void
    public checkContext(): Promise<string>
    public checkContext(callback?: (e?: Error|object, r?: string) => void): Promise<string>|void {
        this._seqid = this.new_seqid()
        if (callback instanceof Function) {
            this._reqs[this.seqid()] = callback
            this.send_checkContext()
        } else {
            return new Promise<string>((resolve, reject) => {
                this._reqs[this.seqid()] = function(error, result) {
                    if (error) {
                        reject(error)
                    } else {
                        resolve(result)
                    }
                }
                this.send_checkContext()
            })
        }
    }

    public send_checkContext(): void {
        const output = new (this.pClass as any)(this.output)
        output.writeMessageBegin("checkContext", Thrift.MessageType.CALL, this.seqid())
        const args = new FinagleTestServiceCheckContextArgs()
        args.populate({  })
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }

    public recv_checkContext(input: Protocol, mtype: Thrift.MessageType, rseqid: number): void {
        const noop = () => null
        let callback = this._reqs[rseqid] || noop
        delete this._reqs[rseqid]
        if (mtype === Thrift.MessageType.EXCEPTION) {
            const x = new Thrift.TApplicationException()
            x.read(input)
            input.readMessageEnd()
            return callback(x)
        }
        const result = new FinagleTestServiceCheckContextResult()
        result.read(input)
        input.readMessageEnd()

        // Dont check if
        if (result.success != null) {
            return callback(undefined, result.success)
        }
        return callback(new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, "checkContext failed: unknown result"))
    }
    }

export class Processor {
    private _handler

    constructor(handler) {
        this._handler = handler
    }

    public process(input: Protocol, output: Protocol) {
        const r = input.readMessageBegin()
        if (this["process_" + r.fname]) {
            return this["process_" + r.fname].call(this, r.rseqid, input, output)
        } else {
            input.skip(Thrift.Type.STRUCT)
            input.readMessageEnd()
            const err = `Unknown function ${r.fname}`
            const x = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN_METHOD, err)
            output.writeMessageBegin(r.fname, Thrift.MessageType.EXCEPTION, r.rseqid)
            x.write(output)
            output.writeMessageEnd()
            output.flush()
        }
    }

    public process_willSucceed(seqid: number, input: Protocol, output: Protocol) {
        const args = new FinagleTestServiceWillSucceedArgs()
        args.read(input)
        input.readMessageEnd()
        if (this._handler.willSucceed.length === 1) {
            // TODO: Im a bit iffy on this
            new Promise<ExampleResponse>((resolve, reject) => {
                try {
                    resolve(
                        this._handler.willSucceed(args.req, )
                    )
                } catch (e) {
                    reject(e)
                }
            }).then((data: ExampleResponse) => {
                const result = new FinagleTestServiceWillSucceedResult({success: data})
                output.writeMessageBegin("willSucceed", Thrift.MessageType.REPLY, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            }).catch((err: Error) => {
                const result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                output.writeMessageBegin("willSucceed", Thrift.MessageType.EXCEPTION, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        } else {
            this._handler.willSucceed(args.req, (err?: Error, data?: ExampleResponse) => {
                let result
                if (err == null) {
                    result = new FinagleTestServiceWillSucceedResult()
                    result.populate((err != null ? err : {success: data}))
                    output.writeMessageBegin("willSucceed", Thrift.MessageType.REPLY, seqid)
                } else {
                    result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                    output.writeMessageBegin("willSucceed", Thrift.MessageType.EXCEPTION, seqid)
                }
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        }
    }
    public process_idlException(seqid: number, input: Protocol, output: Protocol) {
        const args = new FinagleTestServiceIdlExceptionArgs()
        args.read(input)
        input.readMessageEnd()
        if (this._handler.idlException.length === 1) {
            // TODO: Im a bit iffy on this
            new Promise<ExampleResponse>((resolve, reject) => {
                try {
                    resolve(
                        this._handler.idlException(args.req, )
                    )
                } catch (e) {
                    reject(e)
                }
            }).then((data: ExampleResponse) => {
                const result = new FinagleTestServiceIdlExceptionResult({success: data})
                output.writeMessageBegin("idlException", Thrift.MessageType.REPLY, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            }).catch((err: Error) => {
                const result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                output.writeMessageBegin("idlException", Thrift.MessageType.EXCEPTION, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        } else {
            this._handler.idlException(args.req, (err?: Error, data?: ExampleResponse) => {
                let result
                if (err == null) {
                    result = new FinagleTestServiceIdlExceptionResult()
                    result.populate((err != null ? err : {success: data}))
                    output.writeMessageBegin("idlException", Thrift.MessageType.REPLY, seqid)
                } else {
                    result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                    output.writeMessageBegin("idlException", Thrift.MessageType.EXCEPTION, seqid)
                }
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        }
    }
    public process_authException(seqid: number, input: Protocol, output: Protocol) {
        const args = new FinagleTestServiceAuthExceptionArgs()
        args.read(input)
        input.readMessageEnd()
        if (this._handler.authException.length === 1) {
            // TODO: Im a bit iffy on this
            new Promise<ExampleResponse>((resolve, reject) => {
                try {
                    resolve(
                        this._handler.authException(args.req, )
                    )
                } catch (e) {
                    reject(e)
                }
            }).then((data: ExampleResponse) => {
                const result = new FinagleTestServiceAuthExceptionResult({success: data})
                output.writeMessageBegin("authException", Thrift.MessageType.REPLY, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            }).catch((err: Error) => {
                const result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                output.writeMessageBegin("authException", Thrift.MessageType.EXCEPTION, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        } else {
            this._handler.authException(args.req, (err?: Error, data?: ExampleResponse) => {
                let result
                if (err == null) {
                    result = new FinagleTestServiceAuthExceptionResult()
                    result.populate((err != null ? err : {success: data}))
                    output.writeMessageBegin("authException", Thrift.MessageType.REPLY, seqid)
                } else {
                    result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                    output.writeMessageBegin("authException", Thrift.MessageType.EXCEPTION, seqid)
                }
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        }
    }
    public process_otherException(seqid: number, input: Protocol, output: Protocol) {
        const args = new FinagleTestServiceOtherExceptionArgs()
        args.read(input)
        input.readMessageEnd()
        if (this._handler.otherException.length === 1) {
            // TODO: Im a bit iffy on this
            new Promise<ExampleResponse>((resolve, reject) => {
                try {
                    resolve(
                        this._handler.otherException(args.req, )
                    )
                } catch (e) {
                    reject(e)
                }
            }).then((data: ExampleResponse) => {
                const result = new FinagleTestServiceOtherExceptionResult({success: data})
                output.writeMessageBegin("otherException", Thrift.MessageType.REPLY, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            }).catch((err: Error) => {
                const result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                output.writeMessageBegin("otherException", Thrift.MessageType.EXCEPTION, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        } else {
            this._handler.otherException(args.req, (err?: Error, data?: ExampleResponse) => {
                let result
                if (err == null) {
                    result = new FinagleTestServiceOtherExceptionResult()
                    result.populate((err != null ? err : {success: data}))
                    output.writeMessageBegin("otherException", Thrift.MessageType.REPLY, seqid)
                } else {
                    result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                    output.writeMessageBegin("otherException", Thrift.MessageType.EXCEPTION, seqid)
                }
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        }
    }
    public process_checkContext(seqid: number, input: Protocol, output: Protocol) {
        const args = new FinagleTestServiceCheckContextArgs()
        args.read(input)
        input.readMessageEnd()
        if (this._handler.checkContext.length === 0) {
            // TODO: Im a bit iffy on this
            new Promise<string>((resolve, reject) => {
                try {
                    resolve(
                        this._handler.checkContext()
                    )
                } catch (e) {
                    reject(e)
                }
            }).then((data: string) => {
                const result = new FinagleTestServiceCheckContextResult({success: data})
                output.writeMessageBegin("checkContext", Thrift.MessageType.REPLY, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            }).catch((err: Error) => {
                const result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                output.writeMessageBegin("checkContext", Thrift.MessageType.EXCEPTION, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        } else {
            this._handler.checkContext((err?: Error, data?: string) => {
                let result
                if (err == null) {
                    result = new FinagleTestServiceCheckContextResult()
                    result.populate((err != null ? err : {success: data}))
                    output.writeMessageBegin("checkContext", Thrift.MessageType.REPLY, seqid)
                } else {
                    result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                    output.writeMessageBegin("checkContext", Thrift.MessageType.EXCEPTION, seqid)
                }
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        }
    }
    
}
