import thrift from 'thrift'
import {Thrift, Protocol, Transport, Int64, AnyProtocolClass} from 'thrift'

{{#structs}}
import { {{StructName}} } from './{{StructName}}'
{{/structs}}

{{#syncFunctionStructs}}
{{#argsStruct}}{{>struct}}{{/argsStruct}}
{{#resultStruct}}{{>struct}}{{/resultStruct}}
{{/syncFunctionStructs}}

export class Client {
    private _seqid: number
    public _reqs: {[key: string]: (e?: Error|object, r?: any) => void}

    constructor(public output: Transport, public pClass: AnyProtocolClass) {
        this._seqid = 0
        this._reqs = {}
    }

    public seqid(): number {
        return this._seqid
    }

    public new_seqid(): number {
        return this._seqid += 1
    }

{{#syncFunctions}}
    public {{name}}({{#args}}{{fieldName}}: {{fieldType}}, {{/args}}callback: (e?: Error|object, r?: {{typeName}}) => void): void
    public {{name}}({{#args}}{{fieldName}}: {{fieldType}}, {{/args}}): Promise<{{typeName}}>
    public {{name}}({{#args}}{{fieldName}}: {{fieldType}}, {{/args}}callback?: (e?: Error|object, r?: {{typeName}}) => void): Promise<{{typeName}}>|void {
        this._seqid = this.new_seqid()
        if (callback instanceof Function) {
            this._reqs[this.seqid()] = callback
            this.send_{{name}}({{#args}}{{fieldName}}, {{/args}})
        } else {
            return new Promise<{{typeName}}>((resolve, reject) => {
                this._reqs[this.seqid()] = function(error, result) {
                    if (error) {
                        reject(error)
                    } else {
                        resolve(result)
                    }
                }
                this.send_{{name}}({{#args}}{{fieldName}}, {{/args}})
            })
        }
    }

    public send_{{name}}({{#args}}{{fieldName}}: {{fieldType}}, {{/args}}): void {
        const output = new (this.pClass as any)(this.output)
        output.writeMessageBegin("{{name}}", Thrift.MessageType.CALL, this.seqid())
        const args = new {{ServiceName}}{{nameTitleCase}}Args()
        args.populate({ {{#args}}{{fieldName}}, {{/args}} })
        args.write(output)
        output.writeMessageEnd()
        return this.output.flush()
    }

    public recv_{{name}}(input: Protocol, mtype: Thrift.MessageType, rseqid: number): void {
        const noop = () => null
        let callback = this._reqs[rseqid] || noop
        delete this._reqs[rseqid]
        if (mtype === Thrift.MessageType.EXCEPTION) {
            const x = new Thrift.TApplicationException()
            x.read(input)
            input.readMessageEnd()
            return callback(x)
        }
        const result = new {{ServiceName}}{{nameTitleCase}}Result()
        result.read(input)
        input.readMessageEnd()

        // Dont check if
        {{#throws}}if (result.{{throwName}} != null) {
            return callback(result.{{throwName}})
        }
        {{/throws}}
{{^isVoid}}
        if (result.success != null) {
            return callback(undefined, result.success)
        }
{{/isVoid}}
        return callback(new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, "{{name}} failed: unknown result"))
    }
    {{/syncFunctions}}
}

export class Processor {
    private _handler

    constructor(handler) {
        this._handler = handler
    }

    public process(input: Protocol, output: Protocol) {
        const r = input.readMessageBegin()
        if (this["process_" + r.fname]) {
            return this["process_" + r.fname].call(this, r.rseqid, input, output)
        } else {
            input.skip(Thrift.Type.STRUCT)
            input.readMessageEnd()
            const err = `Unknown function ${r.fname}`
            const x = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN_METHOD, err)
            output.writeMessageBegin(r.fname, Thrift.MessageType.EXCEPTION, r.rseqid)
            x.write(output)
            output.writeMessageEnd()
            output.flush()
        }
    }

    {{#syncFunctions}}public process_{{name}}(seqid: number, input: Protocol, output: Protocol) {
        const args = new {{ServiceName}}{{nameTitleCase}}Args()
        args.read(input)
        input.readMessageEnd()
        if (this._handler.{{name}}.length === {{argsLength}}) {
            // TODO: Im a bit iffy on this
            new Promise<{{typeName}}>((resolve, reject) => {
                try {
                    resolve(
                        this._handler.{{name}}({{#args}}args.{{fieldName}}, {{/args}})
                    )
                } catch (e) {
                    reject(e)
                }
            }).then((data: {{typeName}}) => {
                const result = new {{ServiceName}}{{nameTitleCase}}Result({success: data})
                output.writeMessageBegin("{{name}}", Thrift.MessageType.REPLY, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            }).catch((err: Error) => {
                let result
                {{#hasThrows}}{{#throws}}if (err instanceof {{throwType}}) {
                    result = new {{ServiceName}}{{nameTitleCase}}Result()
                    result.populate({{{throwName}}: err as {{throwType}}})
                    output.writeMessageBegin("{{name}}", Thrift.MessageType.REPLY, seqid)
                } else {{/throws}}{
                    result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                    output.writeMessageBegin("{{name}}", Thrift.MessageType.EXCEPTION, seqid)
                }
                result.write(output)
                output.writeMessageEnd()
                output.flush()
                {{/hasThrows}}
                {{^hasThrows}}
                result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                output.writeMessageBegin("{{name}}", Thrift.MessageType.EXCEPTION, seqid)
                result.write(output)
                output.writeMessageEnd()
                output.flush()
                {{/hasThrows}}
            })
        } else {
            this._handler.{{name}}({{#args}}args.{{fieldName}}, {{/args}}(err?: Error, data?: {{typeName}}) => {
                let result
                if (err == null) {
                    result = new {{ServiceName}}{{nameTitleCase}}Result()
                    result.populate((err != null ? err : {success: data}))
                    output.writeMessageBegin("{{name}}", Thrift.MessageType.REPLY, seqid)
                {{#throws}}} else if (err instanceof {{throwType}}) {
                    result = new {{ServiceName}}{{nameTitleCase}}Result()
                    result.populate({{{throwName}}: err as {{throwType}}})
                    output.writeMessageBegin("{{name}}", Thrift.MessageType.REPLY, seqid)
                {{/throws}}} else {
                    result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message)
                    output.writeMessageBegin("{{name}}", Thrift.MessageType.EXCEPTION, seqid)
                }
                result.write(output)
                output.writeMessageEnd()
                output.flush()
            })
        }
    }
    {{/syncFunctions}}
}

